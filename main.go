package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"
	"flag"
)

var LoadSavedData = false
var SaveRequest = true
var SaveFileName = "./response.json"

func main() {
	flag.BoolVar(&LoadSavedData, "l", false, "Load from response.json instead of scrapping LinkedIn")
	flag.BoolVar(&SaveRequest, "s", true, "Save the LinkedIn scrape to response.json")
	flag.Parse()
	fmt.Println(LoadSavedData)
	fmt.Println(SaveRequest)

	allResponses := make([]UsefulResponse, 0)

	if LoadSavedData {
		success := false
		allResponses, success = ReadUsefulResponseFile(SaveFileName)
		if !success{
			fmt.Println("response.json not loaded")
			os.Exit(1)
		}
	}else{
		allResponses = make([]UsefulResponse, 0)
		curlInput := getHeaderValues()
		index := 0
		for {
			agr := GetXRequestInfo(curlInput, index)
			res := UselessToUsefulResponseStruct(agr)
			allResponses = append(allResponses, res...)
			//I think we could actually do index = len(allResponses) - 1
			index += len(res)
			if len(res) == 0 {
				break
			}
		}
		if SaveRequest{
			WriteUsefulResponseFile(SaveFileName, allResponses)
		}
	}

	

	/* for x := range res{
		fmt.Printf("%+v\n", res[x])
	} */
	fmt.Println("Ready To Search")
	//Going to presort by time
	sort.Slice(allResponses, func(i, j int) bool {
		return allResponses[i].ViewedTime.Before(allResponses[j].ViewedTime)
	})

	now := time.Now()
	//Cutting off two weeks ago
	cutOff := now.Add(-time.Hour * 24 * 14)
	for x := range allResponses {
		ti := allResponses[x].ViewedTime
		if cutOff.After(ti) {
			break
		}
		fmt.Println(ti)
	}

	inputReader := bufio.NewReader(os.Stdin)
	for {
		fmt.Println("Would you like to search?")
		str, err := inputReader.ReadString('\n')
		pError(err)
		str = strings.TrimSpace(str)
		if str == "y" {
			fmt.Println("Search by Company Name(cn), Position Title(pt)...?")
			str, err = inputReader.ReadString('\n')
			str = strings.TrimSpace(str)
			pError(err)
			if str == "cn" {
				fmt.Println("Please enter a string to search for")
				str, err = inputReader.ReadString('\n')
				str := strings.TrimSuffix(str, "\r")
				pError(err)
				str = strings.TrimSpace(str)
				foundJobs := searchAllJobsForCompanyName(allResponses, str)
				file, _ := json.MarshalIndent(foundJobs, "", " ")

				_ = ioutil.WriteFile("output.json", file, 0644)
			}
		} else {
			fmt.Println("'" + str + "'")
			break
		}
	}

	/* b, err := ioutil.ReadAll(res.Body)
	if err != nil{
		panic(err)
	}

	fmt.Println(string(b)) */
}

func searchAllJobsForCompanyName(allResponses []UsefulResponse, term string) []UsefulResponse {
	found := make([]UsefulResponse, 0)
	term = strings.ToLower(term)
	for x := range allResponses {
		if strings.Contains(strings.ToLower(allResponses[x].Company), term) {
			found = append(found, allResponses[x])
		}
	}

	return found
}

func GetXRequestInfo(curlInput CURLInputMyParse, index int) (agr AutogeneratedResponse) {
	//Modify the curl input to fix the url
	newURL, err := url.Parse(curlInput.URL)
	pError(err)
	vals := newURL.Query()
	vals.Set("start", strconv.Itoa(index))
	newURL.RawQuery = vals.Encode()
	curlInput.URL, _ = url.QueryUnescape(newURL.String())
	r := CreateRequest(curlInput)
	res, err := http.DefaultClient.Do(r)
	if err != nil {
		panic(err)
	}

	decoder := json.NewDecoder(res.Body)
	err = decoder.Decode(&agr)
	if err != nil {
		panic(err)
	}
	return agr
}

func GetTheOneRequestInfo(curlInput CURLInputMyParse) (agr AutogeneratedResponse) {
	r := CreateRequest(curlInput)
	res, err := http.DefaultClient.Do(r)
	if err != nil {
		panic(err)
	}

	decoder := json.NewDecoder(res.Body)
	err = decoder.Decode(&agr)
	if err != nil {
		panic(err)
	}
	return agr
}

//Need to get all the header information we need to access the users list of jobs.
//So one option is to do a CURL parser. Unsure if I really want to write a full coherent parser, or maybe even use https://github.com/alecthomas/participle
//where I can try and remember my college education on parsers
//Or write a very bad and simple parser that just does line by line

func getHeaderValues() CURLInputMyParse {
	dat, err := os.ReadFile("./curl.txt")
	if err != nil {
		panic(err)
	}
	return ParseMySimpleCurl(string(dat))
}

func CreateRequest(c CURLInputMyParse) (r *http.Request) {
	r, err := http.NewRequest("GET", c.URL, nil)
	if err != nil {
		panic(err)
	}

	for x := range c.Headers {
		r.Header.Add(c.Headers[x].Key, c.Headers[x].Value)
	}

	return r
}

//Cutting down the autogenerated response to just the information we want, not all the other crazy attributes
func UselessToUsefulResponseStruct(agr AutogeneratedResponse) (ufr []UsefulResponse) {
	for _, y := range agr.Included {
		//This is what includes the date since, and a link
		if y.Type == "com.linkedin.voyager.dash.search.EntityResultViewModel" {
			ur := UsefulResponse{}
			timeText := y.Insights[0].Simpleinsight.Title.Text
			ti, vt := ParseStrangeStringTime(timeText)
			ur.ViewedTime = ti
			ur.Viewed = vt

			ur.PostLink = y.Navigationurl
			ur.JobTitle = y.Title.Text
			ur.Company = y.Primarysubtitle.Text
			ufr = append(ufr, ur)
		}
	}
	return ufr
}

//Time is the time. viewed if true = viwed time, false is applied time
func ParseStrangeStringTime(str string) (t time.Time, viewed bool) {
	splits := strings.Split(str, " ") //Should be 3 pieces hopefully
	timeString := ""
	if len(splits) == 3 {
		viewed = false
		timeString = splits[1]
	} else if len(splits) == 4 {
		//could also be downloaded: Resume downloaded 1d ago
		viewed = true
		timeString = splits[2]
	} else if len(splits) == 6 {
		fmt.Println("An invited value")
		timeString = splits[4]
	} else {
		fmt.Println(("A strange time format"))
		panic(str)
	}

	postedTime := time.Now()
	mapStuff := getRegex(`(?P<Time>\d*)(?P<Format>\w*)`, timeString)

	timeInt, err := strconv.ParseInt(mapStuff["Time"], 10, 0)
	if err != nil {
		panic(err)
	}

	howFarBackDuration := -time.Duration(timeInt)
	switch mapStuff["Format"] {
	case "m":
		howFarBackDuration = howFarBackDuration * time.Minute
	case "h":
		//Converting that number into a year
		howFarBackDuration = howFarBackDuration * 60
		fallthrough
	case "d":
		howFarBackDuration = howFarBackDuration * 24
		fallthrough
	case "wk":
		howFarBackDuration = howFarBackDuration * 7
		fallthrough
	case "yr":
		howFarBackDuration = howFarBackDuration * 52
	default:
		fmt.Println("Missing the given case")
		fmt.Println(mapStuff["Format"])
		panic("Missing the stuff")
	}

	postedTime = postedTime.Add(howFarBackDuration)
	return postedTime, viewed
}

func getRegex(regEx, str string) (paramsMap map[string]string) {

	var compRegEx = regexp.MustCompile(regEx)
	match := compRegEx.FindStringSubmatch(str)

	paramsMap = make(map[string]string)
	for i, name := range compRegEx.SubexpNames() {
		if i > 0 && i <= len(match) {
			paramsMap[name] = match[i]
		}
	}
	return paramsMap
}

type UsefulResponse struct {
	JobTitle    string
	PostLink    string
	Company     string
	AppliedTime time.Time
	ViewedTime  time.Time
	Viewed      bool
}

//Will delete the file first
func WriteUsefulResponseFile(fileName string, res []UsefulResponse)(success bool){
	os.Remove(fileName)
	file, err := json.MarshalIndent(res, "", " ")
	if err != nil{
		fmt.Println("Failed to marshall the struct")
		return false
	}
	err = ioutil.WriteFile(fileName, file, 0644)

	if err != nil{
		fmt.Println("Failed to write the struct")
		return false
	}

	return true
}

func ReadUsefulResponseFile(fileName string)(res []UsefulResponse, success bool){
	b, err := os.ReadFile(fileName)
	if err != nil{
		fmt.Println("Failed to read the file")
		return res, false
	}
	err = json.Unmarshal(b, &res)
	if err != nil{
		fmt.Println("Failed to read the file into struct")
		return res, false
	}

	return res, true
}

type AutogeneratedResponse struct {
	Data struct {
		Metadata struct {
			Primaryfiltercluster struct {
				Primaryfilters []struct {
					Displayname struct {
						Textdirection string        `json:"textDirection"`
						Text          string        `json:"text"`
						Attributesv2  []interface{} `json:"attributesV2"`
						Recipetypes   []string      `json:"$recipeTypes"`
						Type          string        `json:"$type"`
					} `json:"displayName"`
					Primaryfiltervalues []struct {
						Displayname string   `json:"displayName"`
						Value       string   `json:"value"`
						Recipetypes []string `json:"$recipeTypes"`
						Selected    bool     `json:"selected"`
						Type        string   `json:"$type"`
					} `json:"primaryFilterValues"`
					Parametername string   `json:"parameterName"`
					Rendertype    string   `json:"renderType"`
					Recipetypes   []string `json:"$recipeTypes"`
					Type          string   `json:"$type"`
				} `json:"primaryFilters"`
				Appliedcount int      `json:"appliedCount"`
				Recipetypes  []string `json:"$recipeTypes"`
				Type         string   `json:"$type"`
			} `json:"primaryFilterCluster"`
			Searchid         string   `json:"searchId"`
			Totalresultcount int      `json:"totalResultCount"`
			Recipetypes      []string `json:"$recipeTypes"`
			Type             string   `json:"$type"`
		} `json:"metadata"`
		Entityurn string `json:"entityUrn"`
		Elements  []struct {
			Results          []string `json:"*results"`
			Totalresultcount int      `json:"totalResultCount"`
			Recipetypes      []string `json:"$recipeTypes"`
			Type             string   `json:"$type"`
		} `json:"elements"`
		Paging struct {
			Total       int           `json:"total"`
			Start       int           `json:"start"`
			Count       int           `json:"count"`
			Links       []interface{} `json:"links"`
			Recipetypes []string      `json:"$recipeTypes"`
			Type        string        `json:"$type"`
		} `json:"paging"`
		Type string `json:"$type"`
	} `json:"data"`
	Included []struct {
		Entityurn                      string      `json:"entityUrn"`
		Unread                         bool        `json:"unread,omitempty"`
		Readindicatoraccessibilitytext interface{} `json:"readIndicatorAccessibilityText,omitempty"`
		Recipetypes                    []string    `json:"$recipeTypes"`
		Type                           string      `json:"$type"`
		Logo                           struct {
			Vectorimage struct {
				Recipetypes []string `json:"$recipeTypes"`
				Rooturl     string   `json:"rootUrl"`
				Artifacts   []struct {
					Width                         int      `json:"width"`
					Recipetypes                   []string `json:"$recipeTypes"`
					Fileidentifyingurlpathsegment string   `json:"fileIdentifyingUrlPathSegment"`
					Expiresat                     int64    `json:"expiresAt"`
					Height                        int      `json:"height"`
					Type                          string   `json:"$type"`
				} `json:"artifacts"`
				Type string `json:"$type"`
			} `json:"vectorImage"`
		} `json:"logo,omitempty"`
		Template                 interface{} `json:"template,omitempty"`
		Actornavigationcontext   interface{} `json:"actorNavigationContext,omitempty"`
		Trackingurn              string      `json:"trackingUrn,omitempty"`
		Controlname              interface{} `json:"controlName,omitempty"`
		Interstitialcomponent    interface{} `json:"interstitialComponent,omitempty"`
		Primaryactions           interface{} `json:"primaryActions,omitempty"`
		Entitycustomtrackinginfo interface{} `json:"entityCustomTrackingInfo,omitempty"`
		Title                    struct {
			Textdirection string        `json:"textDirection"`
			Text          string        `json:"text"`
			Attributesv2  []interface{} `json:"attributesV2"`
			Recipetypes   []string      `json:"$recipeTypes"`
			Type          string        `json:"$type"`
		} `json:"title,omitempty"`
		Overflowactions []struct {
			Searchactiontype    string `json:"searchActionType"`
			Actiondetailsunion2 struct {
				Shareviamessageaction struct {
					Message     string   `json:"message"`
					Recipetypes []string `json:"$recipeTypes"`
					Type        string   `json:"$type"`
				} `json:"shareViaMessageAction"`
			} `json:"actionDetailsUnion,omitempty"`
			Icon struct {
				Attributes []struct {
					Detaildataunion struct {
						Icon string `json:"icon"`
					} `json:"detailDataUnion"`
					Recipetypes []string `json:"$recipeTypes"`
					Type        string   `json:"$type"`
				} `json:"attributes"`
				Recipetypes []string `json:"$recipeTypes"`
				Type        string   `json:"$type"`
			} `json:"icon"`
			Text2 struct {
				Textdirection                 string        `json:"textDirection"`
				Text                          string        `json:"text"`
				Attributesv2                  []interface{} `json:"attributesV2"`
				Accessibilitytextattributesv2 []interface{} `json:"accessibilityTextAttributesV2"`
				Accessibilitytext             string        `json:"accessibilityText"`
				Recipetypes                   []string      `json:"$recipeTypes"`
				Type                          string        `json:"$type"`
			} `json:"text,omitempty"`
			Recipetypes        []string `json:"$recipeTypes"`
			Type               string   `json:"$type"`
			Actiondetailsunion struct {
				Sharevialinkaction struct {
					Recipetypes []string `json:"$recipeTypes"`
					URL         string   `json:"url"`
					Type        string   `json:"$type"`
				} `json:"shareViaLinkAction"`
			} `json:"actionDetailsUnion,omitempty"`
			Text struct {
				Textdirection string        `json:"textDirection"`
				Text          string        `json:"text"`
				Attributesv2  []interface{} `json:"attributesV2"`
				Recipetypes   []string      `json:"$recipeTypes"`
				Type          string        `json:"$type"`
			} `json:"text,omitempty"`
		} `json:"overflowActions,omitempty"`
		Targetunion          interface{} `json:"targetUnion,omitempty"`
		Searchactiontype     interface{} `json:"searchActionType,omitempty"`
		Badgeicon            interface{} `json:"badgeIcon,omitempty"`
		Lazyloadedactionsurn interface{} `json:"lazyLoadedActionsUrn,omitempty"`
		Primarysubtitle      struct {
			Textdirection string        `json:"textDirection"`
			Text          string        `json:"text"`
			Attributesv2  []interface{} `json:"attributesV2"`
			Recipetypes   []string      `json:"$recipeTypes"`
			Type          string        `json:"$type"`
		} `json:"primarySubtitle,omitempty"`
		Badgetext                interface{} `json:"badgeText,omitempty"`
		Trackingid               string      `json:"trackingId,omitempty"`
		Actornavigationurl       interface{} `json:"actorNavigationUrl,omitempty"`
		Addentitytosearchhistory interface{} `json:"addEntityToSearchHistory,omitempty"`
		Summary                  interface{} `json:"summary,omitempty"`
		Image                    struct {
			Attributes []struct {
				Detaildata struct {
					Companylogo string `json:"*companyLogo"`
				} `json:"detailData"`
				Detaildataunion struct {
					Companylogo string `json:"companyLogo"`
				} `json:"detailDataUnion"`
				Recipetypes []string `json:"$recipeTypes"`
				Type        string   `json:"$type"`
			} `json:"attributes"`
			Accessibilitytextattributes []interface{} `json:"accessibilityTextAttributes"`
			Accessibilitytext           string        `json:"accessibilityText"`
			Recipetypes                 []string      `json:"$recipeTypes"`
			Type                        string        `json:"$type"`
		} `json:"image,omitempty"`
		Secondarysubtitle struct {
			Textdirection string        `json:"textDirection"`
			Text          string        `json:"text"`
			Attributesv2  []interface{} `json:"attributesV2"`
			Recipetypes   []string      `json:"$recipeTypes"`
			Type          string        `json:"$type"`
		} `json:"secondarySubtitle,omitempty"`
		Insights []struct {
			Simpleinsight struct {
				Title struct {
					Textdirection string        `json:"textDirection"`
					Text          string        `json:"text"`
					Attributesv2  []interface{} `json:"attributesV2"`
					Recipetypes   []string      `json:"$recipeTypes"`
					Type          string        `json:"$type"`
				} `json:"title"`
				Recipetypes []string `json:"$recipeTypes"`
				Type        string   `json:"$type"`
			} `json:"simpleInsight"`
		} `json:"insights,omitempty"`
		Navigationurl          string `json:"navigationUrl,omitempty"`
		Unreadindicatordetails struct {
			Jobpostingunreadindicator string `json:"*jobPostingUnreadIndicator"`
		} `json:"unreadIndicatorDetails,omitempty"`
		Entityembeddedobject        interface{} `json:"entityEmbeddedObject,omitempty"`
		Unreadindicatordetailsunion struct {
			Jobpostingunreadindicator string `json:"jobPostingUnreadIndicator"`
		} `json:"unreadIndicatorDetailsUnion,omitempty"`
		Actortrackingurn  interface{} `json:"actorTrackingUrn,omitempty"`
		Navigationcontext struct {
			Recipetypes []string `json:"$recipeTypes"`
			URL         string   `json:"url"`
			Type        string   `json:"$type"`
		} `json:"navigationContext,omitempty"`
	} `json:"included"`
}

func pError(err error) {
	if err != nil {
		panic(err)
	}
}
